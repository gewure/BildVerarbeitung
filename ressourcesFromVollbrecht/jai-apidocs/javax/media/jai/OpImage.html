<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.0 Frameset//EN""http://www.w3.org/TR/REC-html40/frameset.dtd">
<!--NewPage-->
<HTML>
<HEAD>
<!-- Generated by javadoc on Tue Jul 08 17:03:56 PDT 2003 -->
<TITLE>
Java Advanced Imaging: Class  OpImage
</TITLE>
<LINK REL ="stylesheet" TYPE="text/css" HREF="../../../stylesheet.css" TITLE="Style">
</HEAD>
<BODY BGCOLOR="white">

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_top"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_top_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/media/jai/OperationRegistry.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/media/jai/PackedImageData.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="OpImage.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>
<!-- ======== START OF CLASS DATA ======== -->
<H2>
<FONT SIZE="-1">
javax.media.jai</FONT>
<BR>
Class  OpImage</H2>
<PRE>
<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html">java.lang.Object</A>
  |
  +--<A HREF="../../../javax/media/jai/PlanarImage.html">javax.media.jai.PlanarImage</A>
        |
        +--<B>javax.media.jai.OpImage</B>
</PRE>
<DL>
<DT><B>All Implemented Interfaces:</B> <DD><A HREF="../../../javax/media/jai/ImageJAI.html">ImageJAI</A>, <A HREF="../../../javax/media/jai/PropertyChangeEmitter.html">PropertyChangeEmitter</A>, <A HREF="../../../javax/media/jai/PropertySource.html">PropertySource</A>, <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>, <A HREF="../../../javax/media/jai/WritablePropertySource.html">WritablePropertySource</A></DD>
</DL>
<DL>
<DT><B>Direct Known Subclasses:</B> <DD><A HREF="../../../javax/media/jai/AreaOpImage.html">AreaOpImage</A>, <A HREF="../../../javax/media/jai/GeometricOpImage.html">GeometricOpImage</A>, <A HREF="../../../javax/media/jai/PointOpImage.html">PointOpImage</A>, <A HREF="../../../javax/media/jai/SourcelessOpImage.html">SourcelessOpImage</A>, <A HREF="../../../javax/media/jai/StatisticsOpImage.html">StatisticsOpImage</A>, <A HREF="../../../javax/media/jai/UntiledOpImage.html">UntiledOpImage</A></DD>
</DL>
<HR>
<DL>
<DT>public abstract class <B>OpImage</B><DT>extends <A HREF="../../../javax/media/jai/PlanarImage.html">PlanarImage</A></DL>

<P>
This is the base class for all image operations.  It provides a home
 for information and functionalities common to all the op-image classes,
 and implements various utility methods that may be useful to a specific
 operation.  Image operations may be divided into different categories
 based on their characteristics.  A subclass, extending
 <code>OpImage</code>, represents a category and implements methods
 unique and common to those operations.  Each individual operator
 should extend the subclass that represents the specific
 category that operator belongs to.

 <p> The layout variables of an <code>OpImage</code> are inherited from the
 <code>PlanarImage</code> superclass.  The layout should be set when the
 <code>OpImage</code> is constructed.  Each subclass must set
 the appropriate layout variables and supply them via the
 <code>ImageLayout</code> argument at construction time.  This class
 simply modifies these settings as described in the <code>OpImage</code>
 constructor comments before forwarding the layout to the
 <code>PlanarImage</code> constructor.  If a subclass needs to modify
 any of the layout settings subsequent to invoking its superclass
 constructors it should use the <code>setImageLayout()</code> method
 defined in <code>PlanarImage</code> in preference to setting the
 layout variables directly.

 <p> A <code>RenderedImage</code>'s pixel data type and number of bands
 are defined by its <code>SampleModel</code>, while the
 <code>ColorModel</code> translates the pixel data into color/alpha
 components in the specific <code>ColorSpace</code> that is associated
 with the <code>ColorModel</code>.

 <p> By default, the operators provided by Java Advanced Imaging (JAI)
 operate on the image's pixel data only.  That is, the computations
 are performed on the data described by the image's
 <code>SampleModel</code>.  No color translation is performed prior
 to the actual computation by the operator, regardless of the type of
 the <code>ColorModel</code> an image has.  If a user intends to have
 an operation performed on the color data, he must perform the
 color translation explicitly prior to invoking the operation.

 <p> There are those operators that specifically deal with the
 color/alpha data of an image.  Such an operator must state its
 behavior in its <code>OperationDescriptor</code> explicitly and
 explain its intended usage of the image's color/alpha component data.
 In such cases, the image's <code>ColorModel</code> as well as the
 associated <code>ColorSpace</code> should be considered.

 <p> However there are certain operations, the results of which are
 incorrect when the source has colormapped imagery, i.e. the source
 has an <code>IndexColorModel</code>, and the computations are
 performed on the image's non color transformed pixel data. In JAI,
 such operations are those that are implemented as subclasses of
 <A HREF="../../../javax/media/jai/AreaOpImage.html"><CODE>AreaOpImage</CODE></A>, <A HREF="../../../javax/media/jai/GeometricOpImage.html"><CODE>GeometricOpImage</CODE></A>, and the "format" 
 operation. These operations set the 
 <A HREF="../../../javax/media/jai/JAI.html#KEY_REPLACE_INDEX_COLOR_MODEL"><CODE>JAI.KEY_REPLACE_INDEX_COLOR_MODEL</CODE></A> <code>RenderingHint</code>
 to true, thus ensuring that the operations are performed correctly 
 on the colormapped imagery, not treating the indices into the color
 map as pixel data. 

 <p> The tile cache and scheduler are handled by this class.  JAI
 provides a default implementation for <code>TileCache</code> and
 <code>TileScheduler</code>.  However, they may be overriden by
 each application.  An <code>OpImage</code> may share a common cache
 with other <code>OpImage</code>s, or it may have a private cache of
 its own.  To override an existing cache, use the
 <code>setTileCache</code> method; an input argument of <code>null</code>
 indicates that this image should not have a tile cache.

 <p> The <code>getTile</code> method may be used to request a tile
 of the image.  The default implementation of this method in this
 class first checks whether the requested tile is in the tile cache,
 and if not, uses the default <code>TileScheduler</code> to schedule
 the tile for computation.  Once the tile has been computed, it is
 added to the cache and returned as a <code>Raster</code>.

 <p> The JAI tile scheduler assumes that when a request is made to
 schedule a tile for computation via the <code>scheduleTile</code>
 method, that tile is not currently in the cache.  To avoid a cycle,
 it calls <code>OpImage.computeTile</code> for the actual tile
 computation.

 <p> The default implementation of the <code>computeTile</code> method 
 in this class first creates a new <code>Raster</code> to represent
 the requested tile, then calls one of the two <code>computeRect</code>
 methods to compute the actual pixel values and store the result in
 the <code>DataBuffer</code> of the <code>Raster</code>.

 <p> Two variants of the <code>computeRect</code> method exist.

 <p> The first (with input arguments <code>Raster[]</code>,
 <code>WritableRaster</code>, and <code>Rectangle</code>) is used when
 the <code>OpImage</code> is constructed with the
 <code>cobbleSources</code> argument set to <code>true</code>.
 This indicates that the source data must be cobbled into a single
 <code>Raster</code> and that all the necessary source data are provided
 in order to compute the rectangular region of the destination image.
 The source <code>Raster</code> array contains one entry for each
 source image.

 <p> The second (with input arguments <code>PlanarImage[]</code>,
 <code>WritableRaster</code>, and <code>Rectangle</code>) is used when
 the <code>OpImage</code> is constructed with the
 <code>cobbleSources</code> argument set to <code>false</code>.
 This indicates that the source data are not cobbled into a single
 <code>Raster</code>; instead an array of <code>PlanarImage</code>s,
 one for each source, supply the source data and each image is
 responsible for performing its own data accesses.  This variant is
 generally useful if iterators are to be used for the underlying
 implementation of accessing the image data.

 <p> The two <code>computeRect</code> methods are not abstract because
 normally only one needs to be implemented by the subclass depending on
 the <code>cobbleSources</code> value.  The default implementation of
 these two methods in this class throws a <code>RuntimeException</code>.

 <p> Every operator who follows the above default implementation must
 supply an overridden version of at least one of the
 <code>computeRect</code> method variants, and specify which one is
 to be called via the <code>cobbleSources</code> argument of the
 constructor, or an exception will be thrown at run time.

 <p> If a subclass overrides <code>getTile</code> not to call
 <code>computeTile</code>, does not use the JAI implementation of
 <code>TileScheduler</code>, overrides <code>computeTile</code> not to
 call <code>computeRect</code>, or does not follow the above default
 implementation in any way, then it may need to handle issues such as
 tile caching, multi-threading, and etc. by itself and may not need to
 override some of the methods described above.  In some cases, some of
 the methods or variables are even irrelevant.  However, subclasses
 should be careful when not following the default path for computing
 a tile.  Most importantly, when a subclass overrides
 <code>getTile</code>, it should also override <code>computeTile</code>.

 <p> To request multiple tiles at a time, it is preferable to
 call the <code>getTiles</code> method with a complete list of the
 requested tiles' indices, than to call <code>getTile</code> once
 per tile.  The implementation of <code>getTiles</code> in this class
 is optimized using multi-threading so that multiple tiles are
 computed simultaneously.
<P>
<DL>
<DT><B>See Also: </B><DD><A HREF="../../../javax/media/jai/PlanarImage.html"><CODE>PlanarImage</CODE></A>, 
<A HREF="../../../javax/media/jai/AreaOpImage.html"><CODE>AreaOpImage</CODE></A>, 
<A HREF="../../../javax/media/jai/GeometricOpImage.html"><CODE>GeometricOpImage</CODE></A>, 
<A HREF="../../../javax/media/jai/PointOpImage.html"><CODE>PointOpImage</CODE></A>, 
<A HREF="../../../javax/media/jai/StatisticsOpImage.html"><CODE>StatisticsOpImage</CODE></A>, 
<A HREF="../../../javax/media/jai/SourcelessOpImage.html"><CODE>SourcelessOpImage</CODE></A></DL>
<HR>

<P>
<!-- ======== INNER CLASS SUMMARY ======== -->


<!-- =========== FIELD SUMMARY =========== -->

<A NAME="field_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Field Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../javax/media/jai/TileCache.html">TileCache</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#cache">cache</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;The cache object used to cache this image's tiles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#cobbleSources">cobbleSources</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Indicates which one of the two <code>computeRect</code> variants
 should be called by the <code>computeTile</code> method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#OP_COMPUTE_BOUND">OP_COMPUTE_BOUND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A constant indicating that an operation is likely to
 spend its time mainly performing computation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#OP_IO_BOUND">OP_IO_BOUND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A constant indicating that an operation is likely to
 spend its time mainly performing local I/O.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#OP_NETWORK_BOUND">OP_NETWORK_BOUND</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A constant indicating that an operation is likely to
 spend its time mainly performing network I/O.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#tileCacheMetric">tileCacheMetric</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Metric used to produce an ordered list of tiles.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../javax/media/jai/TileRecycler.html">TileRecycler</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#tileRecycler">tileRecycler</A></B></CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A <code>TileRecycler</code> for use in <code>createTile()</code>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="fields_inherited_from_class_javax.media.jai.PlanarImage"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Fields inherited from class javax.media.jai.<A HREF="../../../javax/media/jai/PlanarImage.html">PlanarImage</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/media/jai/PlanarImage.html#colorModel">colorModel</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#eventManager">eventManager</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#height">height</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#minX">minX</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#minY">minY</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#properties">properties</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#sampleModel">sampleModel</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#tileFactory">tileFactory</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#tileGridXOffset">tileGridXOffset</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#tileGridYOffset">tileGridYOffset</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#tileHeight">tileHeight</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#tileWidth">tileWidth</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#width">width</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<!-- ======== CONSTRUCTOR SUMMARY ======== -->

<A NAME="constructor_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Constructor Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#OpImage(java.util.Vector, javax.media.jai.ImageLayout, java.util.Map, boolean)">OpImage</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/util/Vector.html">Vector</A>&nbsp;sources,
        <A HREF="../../../javax/media/jai/ImageLayout.html">ImageLayout</A>&nbsp;layout,
        <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/util/Map.html">Map</A>&nbsp;configuration,
        boolean&nbsp;cobbleSources)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Constructor.</TD>
</TR>
</TABLE>
&nbsp;
<!-- ========== METHOD SUMMARY =========== -->

<A NAME="method_summary"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=2><FONT SIZE="+2">
<B>Method Summary</B></FONT></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#addTileToCache(int, int, java.awt.image.Raster)">addTileToCache</A></B>(int&nbsp;tileX,
               int&nbsp;tileY,
               <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A>&nbsp;tile)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Adds a tile to the tile cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#cancelTiles(javax.media.jai.TileRequest, java.awt.Point[])">cancelTiles</A></B>(<A HREF="../../../javax/media/jai/TileRequest.html">TileRequest</A>&nbsp;request,
            <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Point.html">Point</A>[]&nbsp;tileIndices)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Issue an advisory cancellation request to nullify processing of
 the indicated tiles via the TileScheduler for this image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#computeRect(javax.media.jai.PlanarImage[], java.awt.image.WritableRaster, java.awt.Rectangle)">computeRect</A></B>(<A HREF="../../../javax/media/jai/PlanarImage.html">PlanarImage</A>[]&nbsp;sources,
            <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/WritableRaster.html">WritableRaster</A>&nbsp;dest,
            <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A>&nbsp;destRect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes a rectangle of output, given <code>PlanarImage</code>
 sources.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#computeRect(java.awt.image.Raster[], java.awt.image.WritableRaster, java.awt.Rectangle)">computeRect</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A>[]&nbsp;sources,
            <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/WritableRaster.html">WritableRaster</A>&nbsp;dest,
            <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A>&nbsp;destRect)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes a rectangle of output, given <code>Raster</code>
 sources.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#computesUniqueTiles()">computesUniqueTiles</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns <code>true</code> if the <code>OpImage</code> returns an
 unique <code>Raster</code> object every time <code>computeTile</code>
 is called.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#computeTile(int, int)">computeTile</A></B>(int&nbsp;tileX,
            int&nbsp;tileY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the image data of a tile.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/WritableRaster.html">WritableRaster</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#createTile(int, int)">createTile</A></B>(int&nbsp;tileX,
           int&nbsp;tileY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Creates a <code>WritableRaster</code> at the given tile grid position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#dispose()">dispose</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Uncaches all tiles and calls <code>super.dispose()</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>static&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#getExpandedNumBands(java.awt.image.SampleModel, java.awt.image.ColorModel)">getExpandedNumBands</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/SampleModel.html">SampleModel</A>&nbsp;sampleModel,
                    <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/ColorModel.html">ColorModel</A>&nbsp;colorModel)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>as of JAI 1.1.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="../../../javax/media/jai/RasterFormatTag.html">RasterFormatTag</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#getFormatTags()">getFormatTags</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the image's format tags to be used with
 a <code>RasterAccessor</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;int</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#getOperationComputeType()">getOperationComputeType</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns one of <code>OP_COMPUTE_BOUND</code>,
 <code>OP_IO_BOUND</code>, or <code>OP_NETWORK_BOUND</code> to
 indicate how the operation is likely to spend its time.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#getTile(int, int)">getTile</A></B>(int&nbsp;tileX,
        int&nbsp;tileY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a tile of this image as a <code>Raster</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/jai/TileCache.html">TileCache</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#getTileCache()">getTileCache</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the tile cache object of this image by reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html">Object</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#getTileCacheMetric()">getTileCacheMetric</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the <code>tileCacheMetric</code> instance variable by reference.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Point.html">Point</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#getTileDependencies(int, int, int)">getTileDependencies</A></B>(int&nbsp;tileX,
                    int&nbsp;tileY,
                    int&nbsp;sourceIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a list of indices of the tiles of a given source image
 that may be required in order to compute a given tile.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#getTileFromCache(int, int)">getTileFromCache</A></B>(int&nbsp;tileX,
                 int&nbsp;tileY)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Retrieves a tile from the tile cache.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/jai/TileRecycler.html">TileRecycler</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#getTileRecycler()">getTileRecycler</A></B>()</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns the value of the instance variable <code>tileRecycler</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A>[]</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#getTiles(java.awt.Point[])">getTiles</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Point.html">Point</A>[]&nbsp;tileIndices)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the tiles indicated by the given tile indices.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;boolean</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#hasExtender(int)">hasExtender</A></B>(int&nbsp;sourceIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<B>Deprecated.</B>&nbsp;<I>as of JAI 1.1.</I></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/geom/Point2D.html">Point2D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#mapDestPoint(java.awt.geom.Point2D, int)">mapDestPoint</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/geom/Point2D.html">Point2D</A>&nbsp;destPt,
             int&nbsp;sourceIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the position in the specified source that best
 matches the supplied destination image position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#mapDestRect(java.awt.Rectangle, int)">mapDestRect</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A>&nbsp;destRect,
            int&nbsp;sourceIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a conservative estimate of the region of a specified
 source that is required in order to compute the pixels of a
 given destination rectangle.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/geom/Point2D.html">Point2D</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#mapSourcePoint(java.awt.geom.Point2D, int)">mapSourcePoint</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/geom/Point2D.html">Point2D</A>&nbsp;sourcePt,
               int&nbsp;sourceIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Computes the position in the destination that best
 matches the supplied source image position.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>abstract &nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#mapSourceRect(java.awt.Rectangle, int)">mapSourceRect</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A>&nbsp;sourceRect,
              int&nbsp;sourceIndex)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Returns a conservative estimate of the destination region that
 can potentially be affected by the pixels of a rectangle of a
 given source.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#prefetchTiles(java.awt.Point[])">prefetchTiles</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Point.html">Point</A>[]&nbsp;tileIndices)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hints that the given tiles might be needed in the near future.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;<A HREF="../../../javax/media/jai/TileRequest.html">TileRequest</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#queueTiles(java.awt.Point[])">queueTiles</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Point.html">Point</A>[]&nbsp;tileIndices)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Queues a list of tiles for computation.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected &nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#recycleTile(java.awt.image.Raster)">recycleTile</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A>&nbsp;tile)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;A tile recycling convenience method.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>&nbsp;void</CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#setTileCache(javax.media.jai.TileCache)">setTileCache</A></B>(<A HREF="../../../javax/media/jai/TileCache.html">TileCache</A>&nbsp;cache)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Sets the tile cache object of this image.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/util/Vector.html">Vector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#vectorize(java.awt.image.RenderedImage)">vectorize</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stores a <code>RenderedImage</code> in a <code>Vector</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/util/Vector.html">Vector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#vectorize(java.awt.image.RenderedImage, java.awt.image.RenderedImage)">vectorize</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image1,
          <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image2)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stores two <code>RenderedImage</code>s in a <code>Vector</code>.</TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD ALIGN="right" VALIGN="top" WIDTH="1%"><FONT SIZE="-1">
<CODE>protected static&nbsp;<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/util/Vector.html">Vector</A></CODE></FONT></TD>
<TD><CODE><B><A HREF="../../../javax/media/jai/OpImage.html#vectorize(java.awt.image.RenderedImage, java.awt.image.RenderedImage, java.awt.image.RenderedImage)">vectorize</A></B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image1,
          <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image2,
          <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image3)</CODE>

<BR>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Stores three <code>RenderedImage</code>s in a <code>Vector</code>.</TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_javax.media.jai.PlanarImage"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class javax.media.jai.<A HREF="../../../javax/media/jai/PlanarImage.html">PlanarImage</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="../../../javax/media/jai/PlanarImage.html#addPropertyChangeListener(java.beans.PropertyChangeListener)">addPropertyChangeListener</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#addPropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">addPropertyChangeListener</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#addSink(java.lang.Object)">addSink</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#addSink(javax.media.jai.PlanarImage)">addSink</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#addSource(java.lang.Object)">addSource</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#addTileComputationListener(javax.media.jai.TileComputationListener)">addTileComputationListener</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#copyData()">copyData</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#copyData(java.awt.image.WritableRaster)">copyData</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#copyExtendedData(java.awt.image.WritableRaster, javax.media.jai.BorderExtender)">copyExtendedData</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#createColorModel(java.awt.image.SampleModel)">createColorModel</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#createSnapshot()">createSnapshot</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#createWritableRaster(java.awt.image.SampleModel, java.awt.Point)">createWritableRaster</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#finalize()">finalize</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getAsBufferedImage()">getAsBufferedImage</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getAsBufferedImage(java.awt.Rectangle, java.awt.image.ColorModel)">getAsBufferedImage</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getBounds()">getBounds</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getColorModel()">getColorModel</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getData()">getData</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getData(java.awt.Rectangle)">getData</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getDefaultColorModel(int, int)">getDefaultColorModel</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getExtendedData(java.awt.Rectangle, javax.media.jai.BorderExtender)">getExtendedData</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getGraphics()">getGraphics</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getHeight()">getHeight</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getImageID()">getImageID</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getMaxTileX()">getMaxTileX</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getMaxTileY()">getMaxTileY</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getMaxX()">getMaxX</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getMaxY()">getMaxY</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getMinTileX()">getMinTileX</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getMinTileY()">getMinTileY</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getMinX()">getMinX</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getMinY()">getMinY</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getNumBands()">getNumBands</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getNumSources()">getNumSources</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getNumXTiles()">getNumXTiles</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getNumYTiles()">getNumYTiles</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getProperties()">getProperties</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getProperty(java.lang.String)">getProperty</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getPropertyClass(java.lang.String)">getPropertyClass</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getPropertyNames()">getPropertyNames</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getPropertyNames(java.lang.String)">getPropertyNames</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getSampleModel()">getSampleModel</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getSinks()">getSinks</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getSource(int)">getSource</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getSourceImage(int)">getSourceImage</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getSourceObject(int)">getSourceObject</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getSources()">getSources</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getSplits(javax.media.jai.IntegerSequence, javax.media.jai.IntegerSequence, java.awt.Rectangle)">getSplits</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getTileComputationListeners()">getTileComputationListeners</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getTileFactory()">getTileFactory</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getTileGridXOffset()">getTileGridXOffset</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getTileGridYOffset()">getTileGridYOffset</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getTileHeight()">getTileHeight</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getTileIndices(java.awt.Rectangle)">getTileIndices</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getTileRect(int, int)">getTileRect</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getTiles()">getTiles</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getTileWidth()">getTileWidth</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#getWidth()">getWidth</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#overlapsMultipleTiles(java.awt.Rectangle)">overlapsMultipleTiles</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#removeProperty(java.lang.String)">removeProperty</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#removePropertyChangeListener(java.beans.PropertyChangeListener)">removePropertyChangeListener</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#removePropertyChangeListener(java.lang.String, java.beans.PropertyChangeListener)">removePropertyChangeListener</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#removeSink(java.lang.Object)">removeSink</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#removeSink(javax.media.jai.PlanarImage)">removeSink</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#removeSinks()">removeSinks</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#removeSource(java.lang.Object)">removeSource</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#removeSources()">removeSources</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#removeTileComputationListener(javax.media.jai.TileComputationListener)">removeTileComputationListener</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#setImageLayout(javax.media.jai.ImageLayout)">setImageLayout</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#setProperties(java.util.Hashtable)">setProperties</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#setProperty(java.lang.String, java.lang.Object)">setProperty</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#setSource(java.lang.Object, int)">setSource</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#setSources(java.util.List)">setSources</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#tileXToX(int)">tileXToX</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#tileXToX(int, int, int)">tileXToX</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#tileYToY(int)">tileYToY</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#tileYToY(int, int, int)">tileYToY</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#toString()">toString</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#wrapRenderedImage(java.awt.image.RenderedImage)">wrapRenderedImage</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#XToTileX(int)">XToTileX</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#XToTileX(int, int, int)">XToTileX</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#YToTileY(int)">YToTileY</A>, <A HREF="../../../javax/media/jai/PlanarImage.html#YToTileY(int, int, int)">YToTileY</A></CODE></TD>
</TR>
</TABLE>
&nbsp;<A NAME="methods_inherited_from_class_java.lang.Object"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#EEEEFF" CLASS="TableSubHeadingColor">
<TD><B>Methods inherited from class java.lang.<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html">Object</A></B></TD>
</TR>
<TR BGCOLOR="white" CLASS="TableRowColor">
<TD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html#clone()">clone</A>, <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html#equals(java.lang.Object)">equals</A>, <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html#getClass()">getClass</A>, <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html#hashCode()">hashCode</A>, <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html#notify()">notify</A>, <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html#notifyAll()">notifyAll</A>, <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html#wait()">wait</A>, <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html#wait(long)">wait</A>, <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html#wait(long, int)">wait</A></CODE></TD>
</TR>
</TABLE>
&nbsp;
<P>

<!-- ============ FIELD DETAIL =========== -->

<A NAME="field_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Field Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="OP_COMPUTE_BOUND"><!-- --></A><H3>
OP_COMPUTE_BOUND</H3>
<PRE>
public static final int <B>OP_COMPUTE_BOUND</B></PRE>
<DL>
<DD>A constant indicating that an operation is likely to
 spend its time mainly performing computation.</DL>
<HR>

<A NAME="OP_IO_BOUND"><!-- --></A><H3>
OP_IO_BOUND</H3>
<PRE>
public static final int <B>OP_IO_BOUND</B></PRE>
<DL>
<DD>A constant indicating that an operation is likely to
 spend its time mainly performing local I/O.</DL>
<HR>

<A NAME="OP_NETWORK_BOUND"><!-- --></A><H3>
OP_NETWORK_BOUND</H3>
<PRE>
public static final int <B>OP_NETWORK_BOUND</B></PRE>
<DL>
<DD>A constant indicating that an operation is likely to
 spend its time mainly performing network I/O.</DL>
<HR>

<A NAME="cache"><!-- --></A><H3>
cache</H3>
<PRE>
protected transient <A HREF="../../../javax/media/jai/TileCache.html">TileCache</A> <B>cache</B></PRE>
<DL>
<DD>The cache object used to cache this image's tiles.  It may refer
 to a common cache shared by many <code>OpImage</code>s or a private
 cache for this image only.  If it is <code>null</code>, it
 indicates that this image does not have a tile cache.</DL>
<HR>

<A NAME="tileCacheMetric"><!-- --></A><H3>
tileCacheMetric</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html">Object</A> <B>tileCacheMetric</B></PRE>
<DL>
<DD>Metric used to produce an ordered list of tiles.  This determines
 which tiles are removed from the cache first if a memory control
 operation is required.<DD><DL>
<DT><B>Since: </B><DD>JAI 1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cobbleSources"><!-- --></A><H3>
cobbleSources</H3>
<PRE>
protected boolean <B>cobbleSources</B></PRE>
<DL>
<DD>Indicates which one of the two <code>computeRect</code> variants
 should be called by the <code>computeTile</code> method.  If it
 is <code>true</code>, <code>computeRect</code> expects
 contiguous sources.</DL>
<HR>

<A NAME="tileRecycler"><!-- --></A><H3>
tileRecycler</H3>
<PRE>
protected <A HREF="../../../javax/media/jai/TileRecycler.html">TileRecycler</A> <B>tileRecycler</B></PRE>
<DL>
<DD>A <code>TileRecycler</code> for use in <code>createTile()</code>.
 May be <code>null</code>. This field is set by the configuration
 map passed to .<DD><DL>
<DT><B>Since: </B><DD>JAI 1.1.2</DD>
</DL>
</DD>
</DL>

<!-- ========= CONSTRUCTOR DETAIL ======== -->

<A NAME="constructor_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Constructor Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="OpImage(java.util.Vector, javax.media.jai.ImageLayout, java.util.Map, boolean)"><!-- --></A><H3>
OpImage</H3>
<PRE>
public <B>OpImage</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/util/Vector.html">Vector</A>&nbsp;sources,
               <A HREF="../../../javax/media/jai/ImageLayout.html">ImageLayout</A>&nbsp;layout,
               <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/util/Map.html">Map</A>&nbsp;configuration,
               boolean&nbsp;cobbleSources)</PRE>
<DL>
<DD>Constructor.

 <p> The image's layout is encapsulated in the <code>layout</code>
 argument.  The variables of the image layout which are not set in
 the <code>layout</code> parameter are copied from the first source
 if sources are available.  In the case of the <code>ColorModel</code>,
 the copy is performed if and only if the <code>ColorModel</code> is
 compatible with the destination <code>SampleModel</code> and is not
 set by another higher priority mechanism as described presently.</p>

 <p> Assuming that there is at least one source, the image's
 <code>ColorModel</code> will be set by the first applicable means
 in the following priority-ordered list:
 <ol>
 <li><code>null</code> <code>ColorModel</code> from
 <code>ImageLayout</code>;</li>
 <li>Non-<code>null</code> <code>ColorModel</code> from
 <code>ImageLayout</code> if compatible with
 <code>SampleModel</code> in <code>ImageLayout</code> or if
 <code>SampleModel</code> in <code>ImageLayout</code> is
 <code>null</code>;</li>
 <li>Value returned by <code>ColorModelFactory</code> set via the
 <code>JAI.KEY_COLOR_MODEL_FACTORY</code> configuration variable if
 compatible with <code>SampleModel</code>;</li>
 <li>An instance of a non-<code>IndexColorModel</code> (or
 <code>null</code> if no compatible non-<code>IndexColorModel</code> 
 could be generated), if the source has an <code>IndexColorModel</code> 
 and <code>JAI.KEY_REPLACE_INDEX_COLOR_MODEL</code>
 is <code>Boolean.TRUE</code>;</li>
 <li><code>ColorModel</code> of first source if compatible with
 <code>SampleModel</code>;</li>
 <li>Value returned by default method specified by the
 <code>JAI.KEY_DEFAULT_COLOR_MODEL_METHOD</code> configuration variable
 if <code>JAI.KEY_DEFAULT_COLOR_MODEL_ENABLED</code> is
 <code>Boolean.TRUE</code>.</li>
 </ol>
 If it is not possible to set the <code>ColorModel</code> by any of
 these means it will remain <code>null</code>.</p>

 The image's tile dimensions will be set by the first applicable 
 means in the following priority-ordered list. Note that each tile
 dimension, the <code>tileWidth</code> and the
 <code>tileHeight</code>, is considered independently :
 <ol>
 <li>Tile dimension set in the <code>ImageLayout</code> (either by
 the user or the operator itself);</li>
 <li>Tile dimension of source, if source is non-<code>null</code>.
 The tile dimension will be clamped to the minimum of that of the
 source tile dimension and the image's corresponding dimension;</li>
 <li>Non-<code>null</code> default tile size returned by 
 <code>JAI.getDefaultTileSize()</code>, if the corresponding
 image dimension is at least double the default tile size;</li>
 <li>The dimensions of the image itself;</li>
 </ol>

 <p> The <code>sources</code> contains a list of immediate sources
 of this image.  Elements in the list may not be <code>null</code>.
 If this image has no sources this argument should be <code>null</code>.
 This parameter is forwarded unmodified to the <code>PlanarImage</code>
 constructor.

 <p> The <code>configuration</code> contains a mapping of configuration
 variables and image properties.  Entries which have keys of type
 <code>RenderingHints.Key</code> are taken to be configuration variables.
 Entries with a key which is either a <code>String</code> or a
 <code>CaselessStringKey</code> are interpreted as image properties.
 This parameter is forwarded unmodified to the <code>PlanarImage</code>
 constructor.

 <p> This image class recognizes the configuration variables referenced
 by the following keys:

 <ul>
 <li> <code>JAI.KEY_TILE_CACHE</code>: specifies the
 <code>TileCache</code> in which to store the image tiles;
 if this key is not supplied no tile caching will be performed.
 <li> <code>JAI.KEY_TILE_CACHE_METRIC</code>: establishes an
 ordering of tiles stored in the tile cache.  This ordering
 is used to determine which tiles will be removed first, if
 a condition causes tiles to be removed from the cache.
 <li> <code>JAI.KEY_TILE_SCHEDULER</code>: specifies the
 <code>TileScheduler</code> to use to schedule tile computation;
 if this key is not supplied the default scheduler will be used.
 <li> <code>JAI.KEY_COLOR_MODEL_FACTORY</code>: specifies a
 <code>ColorModelFactory</code> to be used to generate the
 <code>ColorModel</code> of the image.  If such a callback is
 provided it will be invoked if and only if either no
 <code>ImageLayout</code> hint is given, or an <code>ImageLayout</code>
 hint is given but contains a non-<code>null</code>
 <code>ColorModel</code> which is incompatible with the image
 <code>SampleModel</code>.  In other words, such a callback provides
 the second priority mechanism for setting the <code>ColorModel</code>
 of the image.</li>
 <li> <code>JAI.KEY_DEFAULT_COLOR_MODEL_ENABLED</code>: specifies whether
 a default <code>ColorModel</code> will be derived
 if none is specified and one cannot be inherited from the first source;
 if this key is not supplied a default <code>ColorModel</code> will be
 computed if necessary.
 <li> <code>JAI.KEY_DEFAULT_COLOR_MODEL_METHOD</code>: specifies the
 method to be used to compute the default <code>ColorModel</code>;
 if this key is not supplied and a default <code>ColorModel</code> is
 required, <code>PlanarImage.createColorModel()</code> will be used to
 compute it.
 <li> <code>JAI.KEY_TILE_FACTORY</code>: specifies a
 <A HREF="../../../javax/media/jai/TileFactory.html"><CODE>TileFactory</CODE></A> to be used to generate the tiles of the
 image via <A HREF="../../../javax/media/jai/TileFactory.html#createTile(java.awt.image.SampleModel, java.awt.Point)"><CODE>TileFactory.createTile(SampleModel,Point)</CODE></A>.  If
 no such configuration variable is given, a new <code>Raster</code>
 will be created for each image tile.  This behavior may be
 overridden by subclasses which have alternate means of saving
 memory, for example as in the case of point operations which
 may overwrite a source image not referenced by user code. Note
 that the corresponding instance variable is actually set by
 the superclass constructor.</li>
 <li> <code>JAI.KEY_TILE_RECYCLER</code>: specifies a
 <A HREF="../../../javax/media/jai/TileRecycler.html"><CODE>TileRecycler</CODE></A> to be used to recycle the tiles of the
 image when the <code>dispose()</code> method is invoked.  If
 such a configuration variable is set, the image has a
 non-<code>null</code> <code>TileCache</code>, and tile recycling
 is enabled, then invoking <code>dispose()</code> will cause each
 of the tiles of this image currently in the cache to be passed to
 the configured <code>TileRecycler</code></li> via
 <A HREF="../../../javax/media/jai/TileRecycler.html#recycleTile(java.awt.image.Raster)"><CODE>TileRecycler.recycleTile(Raster)</CODE></A>.</li>
 <li> <code>JAI.KEY_CACHED_TILE_RECYCLING_ENABLED</code>: specifies a
 <code>Boolean</code> value which indicates whether {#dispose()}
 should pass to <code>tileRecycler.recycleTile()</code> any image
 tiles remaining in the cache.</li>
 </ul>

 <p> The <code>cobbleSources</code> indicates which one of the two
 variants of the <code>computeRect</code> method should be called.
 If a subclass does not follow the default tile computation scheme,
 then this argument may be irrelevant.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>layout</CODE> - The layout of this image.<DD><CODE>sources</CODE> - The immediate sources of this image.<DD><CODE>configuration</CODE> - Configurable attributes of the image including
        configuration variables indexed by
        <code>RenderingHints.Key</code>s and image properties indexed
        by <code>String</code>s or <code>CaselessStringKey</code>s.
        This parameter may be <code>null</code>.<DD><CODE>cobbleSources</CODE> - Indicates which variant of the
        <code>computeRect</code> method should be called.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - If <code>sources</code>
         is non-<code>null</code> and any object in
         <code>sources</code> is <code>null</code>.<DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/RuntimeException.html">RuntimeException</A></CODE> - If default <code>ColorModel</code> setting
         is enabled via a hint in the configuration <code>Map</code>
         and the supplied <code>Method</code> does not conform to the
         requirements stated in the <code>JAI</code> class for the
         hint key <code>KEY_DEFAULT_COLOR_MODEL_METHOD</code>.<DT><B>Since: </B><DD>JAI 1.1</DD>
</DL>
</DD>
</DL>

<!-- ============ METHOD DETAIL ========== -->

<A NAME="method_detail"><!-- --></A>
<TABLE BORDER="1" CELLPADDING="3" CELLSPACING="0" WIDTH="100%">
<TR BGCOLOR="#CCCCFF" CLASS="TableHeadingColor">
<TD COLSPAN=1><FONT SIZE="+2">
<B>Method Detail</B></FONT></TD>
</TR>
</TABLE>

<A NAME="vectorize(java.awt.image.RenderedImage)"><!-- --></A><H3>
vectorize</H3>
<PRE>
protected static <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/util/Vector.html">Vector</A> <B>vectorize</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image)</PRE>
<DL>
<DD>Stores a <code>RenderedImage</code> in a <code>Vector</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>image</CODE> - The image to be stored in the <code>Vector</code>.<DT><B>Returns:</B><DD>A <code>Vector</code> containing the image.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <code>image</code> is
 <code>null</code>.<DT><B>Since: </B><DD>JAI 1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="vectorize(java.awt.image.RenderedImage, java.awt.image.RenderedImage)"><!-- --></A><H3>
vectorize</H3>
<PRE>
protected static <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/util/Vector.html">Vector</A> <B>vectorize</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image1,
                                  <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image2)</PRE>
<DL>
<DD>Stores two <code>RenderedImage</code>s in a <code>Vector</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>image1</CODE> - The first image to be stored in the <code>Vector</code>.<DD><CODE>image2</CODE> - The second image to be stored in the <code>Vector</code>.<DT><B>Returns:</B><DD>A <code>Vector</code> containing the images.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <code>image1</code> or
 <code>image2</code> is <code>null</code>.<DT><B>Since: </B><DD>JAI 1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="vectorize(java.awt.image.RenderedImage, java.awt.image.RenderedImage, java.awt.image.RenderedImage)"><!-- --></A><H3>
vectorize</H3>
<PRE>
protected static <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/util/Vector.html">Vector</A> <B>vectorize</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image1,
                                  <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image2,
                                  <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/RenderedImage.html">RenderedImage</A>&nbsp;image3)</PRE>
<DL>
<DD>Stores three <code>RenderedImage</code>s in a <code>Vector</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>image1</CODE> - The first image to be stored in the <code>Vector</code>.<DD><CODE>image2</CODE> - The second image to be stored in the <code>Vector</code>.<DD><CODE>image3</CODE> - The third image to be stored in the <code>Vector</code>.<DT><B>Returns:</B><DD>A <code>Vector</code> containing the images.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <code>image1</code> or
 <code>image2</code> or <code>image3</code> is <code>null</code>.<DT><B>Since: </B><DD>JAI 1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTileCache()"><!-- --></A><H3>
getTileCache</H3>
<PRE>
public <A HREF="../../../javax/media/jai/TileCache.html">TileCache</A> <B>getTileCache</B>()</PRE>
<DL>
<DD>Returns the tile cache object of this image by reference.
 If this image does not have a tile cache, this method returns
 <code>null</code>.<DD><DL>
<DT><B>Since: </B><DD>JAI 1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="setTileCache(javax.media.jai.TileCache)"><!-- --></A><H3>
setTileCache</H3>
<PRE>
public void <B>setTileCache</B>(<A HREF="../../../javax/media/jai/TileCache.html">TileCache</A>&nbsp;cache)</PRE>
<DL>
<DD>Sets the tile cache object of this image.  A <code>null</code>
 input indicates that this image should have no tile cache and
 subsequently computed tiles will not be cached.

 <p> The existing cache object is informed to release all the
 currently cached tiles of this image.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>cache</CODE> - A cache object to be used for caching this image's
        tiles, or <code>null</code> if no tile caching is desired.</DL>
</DD>
</DL>
<HR>

<A NAME="getTileFromCache(int, int)"><!-- --></A><H3>
getTileFromCache</H3>
<PRE>
protected <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A> <B>getTileFromCache</B>(int&nbsp;tileX,
                                  int&nbsp;tileY)</PRE>
<DL>
<DD>Retrieves a tile from the tile cache.  If this image does not
 have a tile cache, or the requested tile is not currently in
 the cache, this method returns <code>null</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tileX</CODE> - The X index of the tile.<DD><CODE>tileY</CODE> - The Y index of the tile.<DT><B>Returns:</B><DD>The requested tile as a <code>Raster</code> or
         <code>null</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="addTileToCache(int, int, java.awt.image.Raster)"><!-- --></A><H3>
addTileToCache</H3>
<PRE>
protected void <B>addTileToCache</B>(int&nbsp;tileX,
                              int&nbsp;tileY,
                              <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A>&nbsp;tile)</PRE>
<DL>
<DD>Adds a tile to the tile cache.  If this image does not have
 a tile cache, this method does nothing.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tileX</CODE> - The X index of the tile.<DD><CODE>tileY</CODE> - The Y index of the tile.<DD><CODE>tile</CODE> - The tile to be added to the cache.</DL>
</DD>
</DL>
<HR>

<A NAME="getTileCacheMetric()"><!-- --></A><H3>
getTileCacheMetric</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/Object.html">Object</A> <B>getTileCacheMetric</B>()</PRE>
<DL>
<DD>Returns the <code>tileCacheMetric</code> instance variable by reference.<DD><DL>
<DT><B>Since: </B><DD>JAI 1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="getTile(int, int)"><!-- --></A><H3>
getTile</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A> <B>getTile</B>(int&nbsp;tileX,
                      int&nbsp;tileY)</PRE>
<DL>
<DD>Returns a tile of this image as a <code>Raster</code>.  If the
 requested tile is completely outside of this image's bounds,
 this method returns <code>null</code>.

 <p> This method attempts to retrieve the requested tile from the
 cache.  If the tile is not currently in the cache, it schedules
 the tile for computation and adds it to the cache once the tile
 has been computed.

 <p> If a subclass overrides this method, then it needs to handle
 tile caching and scheduling.  It should also override
 <code>computeTile()</code> which may be invoked directly by the
 <code>TileScheduler</code>.<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../javax/media/jai/PlanarImage.html#getTile(int, int)">getTile</A></CODE> in class <CODE><A HREF="../../../javax/media/jai/PlanarImage.html">PlanarImage</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tileX</CODE> - The X index of the tile.<DD><CODE>tileY</CODE> - The Y index of the tile.</DL>
</DD>
</DL>
<HR>

<A NAME="computeTile(int, int)"><!-- --></A><H3>
computeTile</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A> <B>computeTile</B>(int&nbsp;tileX,
                          int&nbsp;tileY)</PRE>
<DL>
<DD>Computes the image data of a tile.

 <p> When a tile is requested via the <code>getTile</code> method
 and that tile is not in this image's tile cache, this method is
 invoked by the <code>TileScheduler</code> to compute the data of
 the new tile.  Even though this method is marked <code>public</code>,
 it should not be called by the applications directly.  Rather, it
 is meant to be called by the <code>TileScheduler</code> for the
 actual computation.

 <p> The implementation of this method in this class assumes that
 the requested tile either intersects the image, or is within the
 image's bounds.  It creates a new <code>Raster</code> to
 represent the requested tile, then calls one of the two variants
 of <code>computeRect</code> to calculate the pixels of the
 tile that are within the image's bounds.  The value of
 <code>cobbleSources</code> determines which variant of
 <code>computeRect</code> is invoked, as described in the class
 comments.

 <p> Subclasses may provide a more optimized implementation of this
 method.  If they override this method not to call either variant of
 <code>computeRect</code>, then neither variant of
 <code>computeRect</code> needs to be implemented.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tileX</CODE> - The X index of the tile.<DD><CODE>tileY</CODE> - The Y index of the tile.</DL>
</DD>
</DL>
<HR>

<A NAME="computeRect(java.awt.image.Raster[], java.awt.image.WritableRaster, java.awt.Rectangle)"><!-- --></A><H3>
computeRect</H3>
<PRE>
protected void <B>computeRect</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A>[]&nbsp;sources,
                           <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/WritableRaster.html">WritableRaster</A>&nbsp;dest,
                           <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A>&nbsp;destRect)</PRE>
<DL>
<DD>Computes a rectangle of output, given <code>Raster</code>
 sources.  This method should be overridden by
 <code>OpImage</code> subclasses that make use of cobbled
 sources, as determined by the setting of the
 <code>cobbleSources</code> constructor argument to this class.

 <p> The source <code>Raster</code>s are guaranteed to include
 at least the area specified by <code>mapDestRect(destRect)</code>
 unless this area is empty or does not intersect the corresponding
 source in which case the source <code>Raster</code>
 will be <code>null</code>.  Only the specified destination region
 should be written.</p>

 <p> Since the subclasses of <code>OpImage</code> may choose
 between the cobbling and non-cobbling versions of
 <code>computeRect</code>, it is not possible to leave this
 method abstract in <code>OpImage</code>.  Instead, a default
 implementation is provided that throws a
 <code>RuntimeException</code>.</p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>sources</CODE> - an array of source <code>Raster</code>s, one per
        source image.<DD><CODE>dest</CODE> - a <code>WritableRaster</code> to be filled in.<DD><CODE>destRect</CODE> - the <code>Rectangle</code> within the
        destination to be written.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/RuntimeException.html">RuntimeException</A></CODE> - If this method is invoked on the subclass
         that sets <code>cobbleSources</code> to <code>true</code>
         but does not supply an implementation of this method.</DL>
</DD>
</DL>
<HR>

<A NAME="computeRect(javax.media.jai.PlanarImage[], java.awt.image.WritableRaster, java.awt.Rectangle)"><!-- --></A><H3>
computeRect</H3>
<PRE>
protected void <B>computeRect</B>(<A HREF="../../../javax/media/jai/PlanarImage.html">PlanarImage</A>[]&nbsp;sources,
                           <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/WritableRaster.html">WritableRaster</A>&nbsp;dest,
                           <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A>&nbsp;destRect)</PRE>
<DL>
<DD>Computes a rectangle of output, given <code>PlanarImage</code>
 sources.  This method should be overridden by
 <code>OpImage</code> subclasses that do not require cobbled
 sources; typically they will instantiate iterators to perform
 source access, but they may access sources directly (via the
 <code>SampleModel</code>/<code>DataBuffer</code> interfaces) if
 they wish.

 <p> Since the subclasses of <code>OpImage</code> may choose
 between the cobbling and non-cobbling versions of
 <code>computeRect</code>, it is not possible to leave this
 method abstract in <code>OpImage</code>.  Instead, a default
 implementation is provided that throws a
 <code>RuntimeException</code>.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sources</CODE> - an array of <code>PlanarImage</code> sources.<DD><CODE>dest</CODE> - a <code>WritableRaster</code> to be filled in.<DD><CODE>destRect</CODE> - the <code>Rectangle</code> within the
 destination to be written.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/RuntimeException.html">RuntimeException</A></CODE> - If this method is invoked on the subclass
         that sets <code>cobbleSources</code> to <code>false</code>
         but does not supply an implementation of this method.</DL>
</DD>
</DL>
<HR>

<A NAME="getTileDependencies(int, int, int)"><!-- --></A><H3>
getTileDependencies</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Point.html">Point</A>[] <B>getTileDependencies</B>(int&nbsp;tileX,
                                   int&nbsp;tileY,
                                   int&nbsp;sourceIndex)</PRE>
<DL>
<DD>Returns a list of indices of the tiles of a given source image
 that may be required in order to compute a given tile.
 Ideally, only tiles that will be requested by means of calls to
 the source's <code>getTile()</code> method should be reported.
 The default implementation uses <code>mapDestRect()</code> to
 obtain a conservative estimate.

 <p> If no dependencies exist, this method returns
 <code>null</code>.

 <p> This method may be used by optimized implementations of JAI
 in order to predict future work and create an optimized
 schedule for performing it.

 <p> A given <code>OpImage</code> may mix calls to
 <code>getTile()</code> with calls to other methods such as
 <code>getData()</code> and <code>copyData()</code> in order to
 avoid requesting entire tiles where only a small portion is
 needed.  In such a case, this method may be overridden to
 provide a more accurate estimate of the set of
 <code>getTile()</code> calls that will actually be performed.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tileX</CODE> - the X index of the tile.<DD><CODE>tileY</CODE> - the Y index of the tile.<DD><CODE>sourceIndex</CODE> - the index of the source image.<DT><B>Returns:</B><DD>An array of <code>Point</code>s indicating the source
         tile dependencies.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - If <code>sourceIndex</code> is
         negative or greater than the index of the last source.</DL>
</DD>
</DL>
<HR>

<A NAME="getTiles(java.awt.Point[])"><!-- --></A><H3>
getTiles</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A>[] <B>getTiles</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Point.html">Point</A>[]&nbsp;tileIndices)</PRE>
<DL>
<DD>Computes the tiles indicated by the given tile indices.  This
 call is preferable to a series of <code>getTile()</code> calls
 because certain implementations can make optimizations based on
 the knowledge that multiple tiles are being asked for at once.

 <p> The implementation of this method in this class uses multiple
 threads to compute multiple tiles at a time.<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../javax/media/jai/PlanarImage.html#getTiles(java.awt.Point[])">getTiles</A></CODE> in class <CODE><A HREF="../../../javax/media/jai/PlanarImage.html">PlanarImage</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tileIndices</CODE> - An array of <code>Point</code>s representing
        tile indices.<DT><B>Returns:</B><DD>An array of <code>Raster</code>s containing the tiles
         corresponding to the given tile indices.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - If <code>tileIndices</code> is
         <code>null</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="queueTiles(java.awt.Point[])"><!-- --></A><H3>
queueTiles</H3>
<PRE>
public <A HREF="../../../javax/media/jai/TileRequest.html">TileRequest</A> <B>queueTiles</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Point.html">Point</A>[]&nbsp;tileIndices)</PRE>
<DL>
<DD>Queues a list of tiles for computation.  Registered listeners will
 be notified after each tile has been computed.  The event source
 parameter passed to such listeners will be the <code>TileScheduler</code>
 and the image parameter will be this image.<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../javax/media/jai/PlanarImage.html#queueTiles(java.awt.Point[])">queueTiles</A></CODE> in class <CODE><A HREF="../../../javax/media/jai/PlanarImage.html">PlanarImage</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tileIndices</CODE> - A list of tile indices indicating which tiles
        to schedule for computation.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - If <code>tileIndices</code> is
         <code>null</code>.<DT><B>Since: </B><DD>JAI 1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="cancelTiles(javax.media.jai.TileRequest, java.awt.Point[])"><!-- --></A><H3>
cancelTiles</H3>
<PRE>
public void <B>cancelTiles</B>(<A HREF="../../../javax/media/jai/TileRequest.html">TileRequest</A>&nbsp;request,
                        <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Point.html">Point</A>[]&nbsp;tileIndices)</PRE>
<DL>
<DD>Issue an advisory cancellation request to nullify processing of
 the indicated tiles via the TileScheduler for this image.  This
 method should merely forward the request to the associated
 <code>TileScheduler</code>.<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../javax/media/jai/PlanarImage.html#cancelTiles(javax.media.jai.TileRequest, java.awt.Point[])">cancelTiles</A></CODE> in class <CODE><A HREF="../../../javax/media/jai/PlanarImage.html">PlanarImage</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>request</CODE> - The request for which tiles are to be cancelled.<DD><CODE>tileIndices</CODE> - The tiles to be cancelled; may be <code>null</code>.
        Any tiles not actually in the <code>TileRequest</code> will be
        ignored.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - If <code>request</code> is
         <code>null</code>.<DT><B>Since: </B><DD>JAI 1.1</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="prefetchTiles(java.awt.Point[])"><!-- --></A><H3>
prefetchTiles</H3>
<PRE>
public void <B>prefetchTiles</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Point.html">Point</A>[]&nbsp;tileIndices)</PRE>
<DL>
<DD>Hints that the given tiles might be needed in the near future.
 Some implementations may spawn one or more threads
 to compute the tiles, while others may ignore the hint.<DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../javax/media/jai/PlanarImage.html#prefetchTiles(java.awt.Point[])">prefetchTiles</A></CODE> in class <CODE><A HREF="../../../javax/media/jai/PlanarImage.html">PlanarImage</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Parameters:</B><DD><CODE>tileIndices</CODE> - A list of tile indices indicating which tiles
        to prefetch.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - If <code>tileIndices</code> is
         <code>null</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="mapDestPoint(java.awt.geom.Point2D, int)"><!-- --></A><H3>
mapDestPoint</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/geom/Point2D.html">Point2D</A> <B>mapDestPoint</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/geom/Point2D.html">Point2D</A>&nbsp;destPt,
                            int&nbsp;sourceIndex)</PRE>
<DL>
<DD>Computes the position in the specified source that best
 matches the supplied destination image position. If it
 is not possible to compute the requested position,
 <code>null</code> will be returned. If the point is mapped
 outside the source bounds, the coordinate value or <code>null</code>
 may be returned at the discretion of the implementation.

 <p>Floating-point input and output coordinates are supported,
 and recommended when possible.  Subclass implementations may
 however use integer computation if necessary for simplicity.</p>

 <p>The implementation in this class returns the value of
 <code>pt</code> in the following code snippet:

 <pre>
 Rectangle destRect = new Rectangle((int)destPt.getX(),
                                    (int)destPt.getY(),
                                    1, 1);
 Rectangle sourceRect = mapDestRect(destRect, sourceIndex);
 Point2D pt = (Point2D)destPt.clone();
 pt.setLocation(sourceRect.x + (sourceRect.width - 1.0)/2.0,
                sourceRect.y + (sourceRect.height - 1.0)/2.0);
 </pre>

 Subclasses requiring different behavior should override this
 method.</p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>destPt</CODE> - the position in destination image coordinates
 to map to source image coordinates.<DD><CODE>sourceIndex</CODE> - the index of the source image.<DT><B>Returns:</B><DD>a <code>Point2D</code> of the same class as
 <code>destPt</code> or <code>null</code>.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <code>destPt</code> is
 <code>null</code>.<DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IndexOutOfBoundsException.html">IndexOutOfBoundsException</A></CODE> - if <code>sourceIndex</code> is
 negative or greater than or equal to the number of sources.<DT><B>Since: </B><DD>JAI 1.1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="mapSourcePoint(java.awt.geom.Point2D, int)"><!-- --></A><H3>
mapSourcePoint</H3>
<PRE>
public <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/geom/Point2D.html">Point2D</A> <B>mapSourcePoint</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/geom/Point2D.html">Point2D</A>&nbsp;sourcePt,
                              int&nbsp;sourceIndex)</PRE>
<DL>
<DD>Computes the position in the destination that best
 matches the supplied source image position. If it
 is not possible to compute the requested position,
 <code>null</code> will be returned. If the point is mapped
 outside the destination bounds, the coordinate value or
 <code>null</code> may be returned at the discretion of the
 implementation.

 <p>Floating-point input and output coordinates are supported,
 and recommended when possible.  Subclass implementations may
 however use integer computation if necessary for simplicity.</p>

 <p>The implementation in this class returns the value of
 <code>pt</code> in the following code snippet:

 <pre>
 Rectangle sourceRect = new Rectangle((int)sourcePt.getX(),
                                      (int)sourcePt.getY(),
                                      1, 1);
 Rectangle destRect = mapSourceRect(sourceRect, sourceIndex);
 Point2D pt = (Point2D)sourcePt.clone();
 pt.setLocation(destRect.x + (destRect.width - 1.0)/2.0,
                destRect.y + (destRect.height - 1.0)/2.0);
 </pre><DD><DL>
<DT><B>Parameters:</B><DD><CODE>sourcePt</CODE> - the position in source image coordinates
 to map to destination image coordinates.<DD><CODE>sourceIndex</CODE> - the index of the source image.<DT><B>Returns:</B><DD>a <code>Point2D</code> of the same class as
 <code>sourcePt</code> or <code>null</code>.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <code>sourcePt</code> is
 <code>null</code>.<DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IndexOutOfBoundsException.html">IndexOutOfBoundsException</A></CODE> - if <code>sourceIndex</code> is
 negative or greater than or equal to the number of sources.<DT><B>Since: </B><DD>JAI 1.1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="mapSourceRect(java.awt.Rectangle, int)"><!-- --></A><H3>
mapSourceRect</H3>
<PRE>
public abstract <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A> <B>mapSourceRect</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A>&nbsp;sourceRect,
                                        int&nbsp;sourceIndex)</PRE>
<DL>
<DD>Returns a conservative estimate of the destination region that
 can potentially be affected by the pixels of a rectangle of a
 given source.  An empty <code>Rectangle</code> may be returned
 if the destination is unaffected by the contents of the source
 rectangle.  This is distinct from a <code>null</code> return value
 which serves rather to indicate that it is not possible to
 determine the bounds of the affected region.  The safest
 interpretation of a <code>null</code> return value is that the
 entire destination might be affected by any pixel within the
 given source rectangle.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sourceRect</CODE> - The <code>Rectangle</code> in source coordinates.<DD><CODE>sourceIndex</CODE> - The index of the source image.<DT><B>Returns:</B><DD>A <code>Rectangle</code> indicating the potentially
         affected destination region, or <code>null</code> if
         the region is unknown.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - If the source index is
         negative or greater than that of the last source.<DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - If <code>sourceRect</code> is
         <code>null</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="mapDestRect(java.awt.Rectangle, int)"><!-- --></A><H3>
mapDestRect</H3>
<PRE>
public abstract <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A> <B>mapDestRect</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/Rectangle.html">Rectangle</A>&nbsp;destRect,
                                      int&nbsp;sourceIndex)</PRE>
<DL>
<DD>Returns a conservative estimate of the region of a specified
 source that is required in order to compute the pixels of a
 given destination rectangle.  The computation may as appropriate
 clip the mapped <code>Rectangle</code> to the actual bounds of the
 source or may treat the source as having infinite extent.
 It is therefore the responsibility of the invoking
 object to constrain the region in accordance with its needs.
 Returning an empty <code>Rectangle</code> should indicate that
 the data of the source image in question are not required for the
 computation of the specified destination region.  If the entire
 source image might be required to compute this destination
 region, then <code>getSourceImage(sourceIndex).getBounds()</code>
 should be returned.

 <p> To illustrate the issue of whether the source should be thought
 to have infinite extent, consider the case wherein computing a
 destination pixel requires multiple source pixels of context.  At
 the source image boundary, these pixels might only be available if the
 source data were extrapolated, e.g., using a <A HREF="../../../javax/media/jai/BorderExtender.html"><CODE>BorderExtender</CODE></A>.
 If such an extender were available, destination pixels could be
 computed even if they mapped to a region on the source boundary so
 in this case the source could be considered to have infinite extent.
 If no such extender were available, only destination pixels with
 source context contained within the source image bounds could be
 considered so that it might be preferable to clip the rectangle to
 the source bounds.</p><DD><DL>
<DT><B>Parameters:</B><DD><CODE>destRect</CODE> - The <code>Rectangle</code> in destination coordinates.<DD><CODE>sourceIndex</CODE> - The index of the source image.<DT><B>Returns:</B><DD>A non-<code>null</code> <code>Rectangle</code> indicating
         the required source region.<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - If the source index is
         negative or greater than that of the last source.<DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - If <code>destRect</code> is
         <code>null</code>.</DL>
</DD>
</DL>
<HR>

<A NAME="getOperationComputeType()"><!-- --></A><H3>
getOperationComputeType</H3>
<PRE>
public int <B>getOperationComputeType</B>()</PRE>
<DL>
<DD>Returns one of <code>OP_COMPUTE_BOUND</code>,
 <code>OP_IO_BOUND</code>, or <code>OP_NETWORK_BOUND</code> to
 indicate how the operation is likely to spend its time.  The
 answer does not affect the output of the operation, but may
 allow a scheduler to parallelize the computation of multiple
 operations more effectively.

 <p> The implementation of this method in this class
 returns <code>OP_COMPUTE_BOUND</code>.</DL>
<HR>

<A NAME="computesUniqueTiles()"><!-- --></A><H3>
computesUniqueTiles</H3>
<PRE>
public boolean <B>computesUniqueTiles</B>()</PRE>
<DL>
<DD>Returns <code>true</code> if the <code>OpImage</code> returns an
 unique <code>Raster</code> object every time <code>computeTile</code>
 is called.  <code>OpImage</code>s that internally cache
 <code>Raster</code>s and return them via <code>computeTile</code>
 should return <code>false</code> for this method.  

 <p> The implementation of this method in this class always returns
 <code>true</code>.</DL>
<HR>

<A NAME="dispose()"><!-- --></A><H3>
dispose</H3>
<PRE>
public void <B>dispose</B>()</PRE>
<DL>
<DD>Uncaches all tiles and calls <code>super.dispose()</code>.
 If a <code>TileRecycler</code> was defined via the configuration
 variable <code>JAI.KEY_TILE_RECYCLER</code> when this image was
 constructed and tile recycling was enabled via the configuration
 variable <code>JAI.KEY_CACHED_TILE_RECYCLING_ENABLED</code>, then each
 of this image's tiles which is currently in the cache will be
 recycled.  This method may be invoked more than once although
 invocations after the first one may do nothing.

 <p> The results of referencing an image after a call to
 <code>dispose()</code> are undefined.</p><DD><DL>
<DT><B>Overrides:</B><DD><CODE><A HREF="../../../javax/media/jai/PlanarImage.html#dispose()">dispose</A></CODE> in class <CODE><A HREF="../../../javax/media/jai/PlanarImage.html">PlanarImage</A></CODE></DL>
</DD>
<DD><DL>
<DT><B>Since: </B><DD>JAI 1.1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="hasExtender(int)"><!-- --></A><H3>
hasExtender</H3>
<PRE>
public boolean <B>hasExtender</B>(int&nbsp;sourceIndex)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>as of JAI 1.1.</I>
<P>
<DD>Indicates whether the source with the given index has a
 <code>BorderExtender</code>. If the source index is out of bounds
 for the source vector of this <code>OpImage</code> then an
 <code>ArrayIndexOutOfBoundsException</code> may be thrown.<DD><DL>
<DT><B>Parameters:</B><DD><CODE>sourceIndex</CODE> - The index of the source in question.<DT><B>Returns:</B><DD><code>true</code> if the indicated source has an extender.</DL>
</DD>
</DL>
<HR>

<A NAME="getExpandedNumBands(java.awt.image.SampleModel, java.awt.image.ColorModel)"><!-- --></A><H3>
getExpandedNumBands</H3>
<PRE>
public static int <B>getExpandedNumBands</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/SampleModel.html">SampleModel</A>&nbsp;sampleModel,
                                      <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/ColorModel.html">ColorModel</A>&nbsp;colorModel)</PRE>
<DL>
<DD><B>Deprecated.</B>&nbsp;<I>as of JAI 1.1.</I>
<P>
<DD>Returns the effective number of bands of an image with a given
 <code>SampleModel</code> and <code>ColorModel</code>.
 Normally, this is given by
 <code>sampleModel.getNumBands()</code>, but for images with an
 <code>IndexColorModel</code> the effective number of bands is
 given by <code>colorModel.getNumComponents()</code>, since
 a single physical sample represents multiple color components.</DL>
<HR>

<A NAME="getFormatTags()"><!-- --></A><H3>
getFormatTags</H3>
<PRE>
protected <A HREF="../../../javax/media/jai/RasterFormatTag.html">RasterFormatTag</A>[] <B>getFormatTags</B>()</PRE>
<DL>
<DD>Returns the image's format tags to be used with
 a <code>RasterAccessor</code>.

 <p> This method will compute and cache the tags the first time
 it is called on a particular image.  The image's
 <code>SampleModel</code> and <code>ColorModel</code> must be
 set to their final values before calling this method.<DD><DL>
<DT><B>Returns:</B><DD>An array containing <code>RasterFormatTag</code>s for the
 sources in the first <code>getNumSources()</code> elements and a
 <code>RasterFormatTag</code> for the destination in the last element.</DL>
</DD>
</DL>
<HR>

<A NAME="getTileRecycler()"><!-- --></A><H3>
getTileRecycler</H3>
<PRE>
public <A HREF="../../../javax/media/jai/TileRecycler.html">TileRecycler</A> <B>getTileRecycler</B>()</PRE>
<DL>
<DD>Returns the value of the instance variable <code>tileRecycler</code>.<DD><DL>
<DT><B>Since: </B><DD>JAI 1.1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="createTile(int, int)"><!-- --></A><H3>
createTile</H3>
<PRE>
protected final <A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/WritableRaster.html">WritableRaster</A> <B>createTile</B>(int&nbsp;tileX,
                                          int&nbsp;tileY)</PRE>
<DL>
<DD>Creates a <code>WritableRaster</code> at the given tile grid position.
 The superclass method <A HREF="../../../javax/media/jai/PlanarImage.html#createWritableRaster(java.awt.image.SampleModel, java.awt.Point)"><CODE>PlanarImage.createWritableRaster(SampleModel,Point)</CODE></A>
 will be invoked with this image's <code>SampleModel</code> and the
 location of the specified tile.

 <p>Subclasses should ideally use this method to create destination
 tiles as this method will take advantage of any
 <code>TileFactory</code> specified to the <code>OpImage</code> at
 construction.</p><DD><DL>
<DT><B>Since: </B><DD>JAI 1.1.2</DD>
</DL>
</DD>
</DL>
<HR>

<A NAME="recycleTile(java.awt.image.Raster)"><!-- --></A><H3>
recycleTile</H3>
<PRE>
protected void <B>recycleTile</B>(<A HREF="http://java.sun.com/j2se/1.3/docs/api/java/awt/image/Raster.html">Raster</A>&nbsp;tile)</PRE>
<DL>
<DD>A tile recycling convenience method.

 <p>If <code>tileRecycler</code> is non-<code>null</code>, the call
 is forwarded to <CODE>TileRecycler.recycleTile(Raster)</CODE>; otherwise
 the method does nothing.</p>

 <p>This method is for use by subclasses which create
 <code>Raster</code>s with limited scope which therefore may easily
 be identified as safe candidates for recycling.  This might occur
 for example within
 <A HREF="../../../javax/media/jai/OpImage.html#computeRect(java.awt.image.Raster[], java.awt.image.WritableRaster, java.awt.Rectangle)"><CODE>computeRect(Raster[],WritableRaster,Rectangle)</CODE></A> or
 <A HREF="../../../javax/media/jai/OpImage.html#computeTile(int, int)"><CODE>computeTile(int,int)</CODE></A> wherein <code>Raster</code>s may be
 created for use within the method but be eligible for garbage
 collection once the method is exited.</p><DD><DL>
<DT><B>Throws:</B><DD><CODE><A HREF="http://java.sun.com/j2se/1.3/docs/api/java/lang/IllegalArgumentException.html">IllegalArgumentException</A></CODE> - if <code>tile</code> is
         <code>null</code>.<DT><B>Since: </B><DD>JAI 1.1.2</DD>
</DL>
</DD>
</DL>
<!-- ========= END OF CLASS DATA ========= -->
<HR>

<!-- ========== START OF NAVBAR ========== -->
<A NAME="navbar_bottom"><!-- --></A>
<TABLE BORDER="0" WIDTH="100%" CELLPADDING="1" CELLSPACING="0">
<TR>
<TD COLSPAN=2 BGCOLOR="#EEEEFF" CLASS="NavBarCell1">
<A NAME="navbar_bottom_firstrow"><!-- --></A>
<TABLE BORDER="0" CELLPADDING="0" CELLSPACING="3">
  <TR ALIGN="center" VALIGN="top">
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../overview-summary.html"><FONT CLASS="NavBarFont1"><B>Overview</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-summary.html"><FONT CLASS="NavBarFont1"><B>Package</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#FFFFFF" CLASS="NavBarCell1Rev"> &nbsp;<FONT CLASS="NavBarFont1Rev"><B>Class</B></FONT>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="package-tree.html"><FONT CLASS="NavBarFont1"><B>Tree</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../deprecated-list.html"><FONT CLASS="NavBarFont1"><B>Deprecated</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../index-all.html"><FONT CLASS="NavBarFont1"><B>Index</B></FONT></A>&nbsp;</TD>
  <TD BGCOLOR="#EEEEFF" CLASS="NavBarCell1">    <A HREF="../../../help-doc.html"><FONT CLASS="NavBarFont1"><B>Help</B></FONT></A>&nbsp;</TD>
  </TR>
</TABLE>
</TD>
<TD ALIGN="right" VALIGN="top" ROWSPAN=3><EM>
</EM>
</TD>
</TR>

<TR>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
&nbsp;<A HREF="../../../javax/media/jai/OperationRegistry.html"><B>PREV CLASS</B></A>&nbsp;
&nbsp;<A HREF="../../../javax/media/jai/PackedImageData.html"><B>NEXT CLASS</B></A></FONT></TD>
<TD BGCOLOR="white" CLASS="NavBarCell2"><FONT SIZE="-2">
  <A HREF="../../../index.html" TARGET="_top"><B>FRAMES</B></A>  &nbsp;
&nbsp;<A HREF="OpImage.html" TARGET="_top"><B>NO FRAMES</B></A></FONT></TD>
</TR>
<TR>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
  SUMMARY: &nbsp;INNER&nbsp;|&nbsp;<A HREF="#field_summary">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_summary">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_summary">METHOD</A></FONT></TD>
<TD VALIGN="top" CLASS="NavBarCell3"><FONT SIZE="-2">
DETAIL: &nbsp;<A HREF="#field_detail">FIELD</A>&nbsp;|&nbsp;<A HREF="#constructor_detail">CONSTR</A>&nbsp;|&nbsp;<A HREF="#method_detail">METHOD</A></FONT></TD>
</TR>
</TABLE>
<!-- =========== END OF NAVBAR =========== -->

<HR>

</BODY>
</HTML>
